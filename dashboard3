<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singapore Green Space Analysis Dashboard</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            background: #0f1115;
            color: #e7e9ee;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            margin-bottom: 30px;
            color: #e7e9ee;
            font-size: 32px;
            text-align: center;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-container {
            width: 100%;
            height: 600px;
            border: 1px solid #202635;
            border-radius: 8px;
            padding: 15px;
            background: #1a1d24;
        }

        .chart-container h2 {
            color: #e7e9ee;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        .chart-container.full-width {
            grid-column: 1 / -1;
            height: 700px;
        }

        .chart-wrapper {
            width: 100%;
            height: calc(100% - 40px);
        }

        svg {
            display: block;
        }

        .tooltip {
            position: fixed;
            pointer-events: none;
            background: #111827;
            color: #f9fafb;
            border: 1px solid #374151;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        .tooltip strong {
            display: block;
            margin-bottom: 6px;
            color: #5dc16b;
            font-size: 14px;
        }

        .axis text {
            fill: #d1d5db;
            font-size: 11px;
        }

        .axis line,
        .axis path {
            stroke: #4b5563;
            stroke-width: 1px;
        }

        .dot {
            stroke: #1a1d24;
            stroke-width: 1px;
            transition: r 0.2s, stroke-width 0.2s;
        }

        .dot:hover {
            r: 7;
            stroke-width: 2;
            stroke: #5dc16b;
        }

        .region {
            stroke: #374151;
            stroke-width: 0.5;
        }

        .region:hover {
            stroke: #5dc16b;
            stroke-width: 2;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>"The Gap" — An Analysis of Green Space Allocation Equity</h1>
        
        <div class="charts-grid">
            <!-- Scatter Plot -->
            <div class="chart-container">
                <h2>Population Density vs Per Capita Green Space</h2>
                <div id="scatter" class="chart-wrapper"></div>
            </div>

            <!-- Diverging Bars -->
            <div class="chart-container">
                <h2>Difference from National Average</h2>
                <div id="bars" class="chart-wrapper"></div>
            </div>

            <!-- Choropleth Map -->
            <div class="chart-container full-width">
                <h2>Per Capita Green Space by Planning Area</h2>
                <div id="map" class="chart-wrapper"></div>
            </div>
        </div>
    </div>

    <div class="tooltip"></div>

    <script>
        const tip = d3.select('.tooltip');

        function showTip(html, x, y) {
            tip.html(html)
                .style('opacity', 1)
                .style('left', (x + 15) + 'px')
                .style('top', (y - 10) + 'px');
        }

        function hideTip() {
            tip.style('opacity', 0);
        }

        function selectPAName(props) {
            if (!props) return null;
            if (props.PLN_AREA_N) return props.PLN_AREA_N;
            if (props.Name && props.Name !== 'kml_1' && !props.Name.startsWith('kml_')) return props.Name;
            if (props.name) return props.name;
            if (props.PA_NAME) return props.PA_NAME;
            if (props.pa) return props.pa;
            
            if (props.Description) {
                let match = props.Description.match(/<th>PLN_AREA_N<\/th>\s*<td>([^<]+)<\/td>/i);
                if (!match) {
                    match = props.Description.match(/PLN_AREA_N[\s\S]*?<td>([^<]+)<\/td>/i);
                }
                if (match && match[1]) {
                    return match[1].trim();
                }
            }
            
            return null;
        }
        
        function findMatchingData(geoName, paByName) {
            if (!geoName) return null;
            
            let name = geoName.toUpperCase().trim();
            let m = paByName.get(name);
            if (m) return m;
            
            if (!m) {
                m = paByName.get(name.replace(/\s+/g, ''));
            }
            
            if (!m) {
                m = paByName.get(name.replace(/[_-]/g, ' '));
            }
            if (!m) {
                m = paByName.get(name.replace(/[_-]/g, ' ').replace(/\s+/g, ''));
            }
            
            if (!m) {
                const cleaned = name.replace(/\s+(TOTAL|TOTAL_|REGION|AREA)$/i, '').trim();
                m = paByName.get(cleaned);
                if (!m) {
                    m = paByName.get(cleaned.replace(/\s+/g, ''));
                }
            }
            
            if (!m) {
                for (const [key, value] of paByName.entries()) {
                    const keyUpper = key.toUpperCase();
                    if (keyUpper.includes(name) || name.includes(keyUpper)) {
                        const commonChars = name.split('').filter(c => keyUpper.includes(c)).length;
                        if (commonChars >= Math.min(3, name.length, keyUpper.length)) {
                            m = value;
                            console.log(`Partial matched: "${name}" -> "${key}"`);
                            break;
                        }
                    }
                }
            }
            
            if (!m) {
                const words = name.split(/\s+/).filter(w => w.length > 2);
                if (words.length > 0) {
                    for (const [key, value] of paByName.entries()) {
                        const keyUpper = key.toUpperCase();
                        if (words.every(word => keyUpper.includes(word)) || 
                            words.some(word => keyUpper.length > 5 && keyUpper.includes(word))) {
                            m = value;
                            console.log(`Fuzzy matched: "${name}" -> "${key}"`);
                            break;
                        }
                    }
                }
            }
            
            return m;
        }

        async function loadData() {
            const csvPaths = [
                'd3-pa-visuals/public/data/pa_metrics.csv',
                'public/data/pa_metrics.csv',
                './data/pa_metrics.csv'
            ];
            
            const geoPaths = [
                'd3-pa-visuals/public/data/sg_pa.geojson',
                'public/data/sg_pa.geojson',
                './data/sg_pa.geojson'
            ];
            
            let metricsData, geoData;
            
            for (const path of csvPaths) {
                try {
                    metricsData = await d3.csv(path);
                    console.log('✓ Loaded CSV from:', path);
                    break;
                } catch (e) {
                    console.log('✗ Failed CSV:', path);
                }
            }
            
            for (const path of geoPaths) {
                try {
                    geoData = await d3.json(path);
                    console.log('✓ Loaded GeoJSON from:', path);
                    break;
                } catch (e) {
                    console.log('✗ Failed GeoJSON:', path);
                }
            }
            
            if (!metricsData || !geoData) {
                throw new Error('无法加载数据文件');
            }
            
            const metrics = metricsData.map(d => ({
                pa: d.pa,
                population: +d.population,
                area_km2: +d.area_km2,
                green_area_km2: +d.green_area_km2,
                green_per_capita_m2: +d.green_per_capita_m2,
                pop_density_per_km2: +d.pop_density_per_km2
            }));
            
            return { metrics, geo: geoData };
        }

        function renderScatter(data) {
            const svg = d3.select('#scatter')
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', '0 0 600 500');

            const margin = { top: 30, right: 30, bottom: 60, left: 70 };
            const width = 600 - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleLinear()
                .domain(d3.extent(data, d => d.pop_density_per_km2))
                .nice()
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain(d3.extent(data, d => d.green_per_capita_m2))
                .nice()
                .range([height, 0]);

            // Grid lines
            g.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickSize(-height).tickFormat('').tickArguments([10]))
                .attr('opacity', 0.1);

            g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat('').tickArguments([10]))
                .attr('opacity', 0.1);

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => d3.format(',.0f')(d)))
                .selectAll('text')
                .attr('fill', '#d1d5db')
                .attr('font-size', '10px');

            g.append('g')
                .call(d3.axisLeft(y).tickFormat(d => d3.format(',.1f')(d)))
                .selectAll('text')
                .attr('fill', '#d1d5db')
                .attr('font-size', '10px');

            // Labels
            g.append('text')
                .attr('x', width / 2)
                .attr('y', height + 50)
                .attr('text-anchor', 'middle')
                .attr('fill', '#e7e9ee')
                .attr('font-size', '13px')
                .attr('font-weight', 'bold')
                .text('Population Density (persons/km²)');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -55)
                .attr('text-anchor', 'middle')
                .attr('fill', '#e7e9ee')
                .attr('font-size', '13px')
                .attr('font-weight', 'bold')
                .text('Per Capita Green Space (m²/person)');

            // Dots
            g.selectAll('.dot')
                .data(data)
                .join('circle')
                .attr('class', 'dot')
                .attr('cx', d => x(d.pop_density_per_km2))
                .attr('cy', d => y(d.green_per_capita_m2))
                .attr('r', 5)
                .attr('fill', '#5dc16b')
                .attr('stroke', '#1a1d24')
                .attr('stroke-width', 1)
                .attr('opacity', 0.7)
                .on('mousemove', (ev, d) => {
                    showTip(`<strong>${d.pa}</strong><br/>Density: ${d3.format(',.0f')(d.pop_density_per_km2)} persons/km²<br/>Per Capita Green: ${d3.format('.2f')(d.green_per_capita_m2)} m²`, ev.clientX, ev.clientY);
                })
                .on('mouseleave', hideTip);
        }

        function renderDivergingBars(metrics) {
            const svg = d3.select('#bars')
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', '0 0 600 500');

            const margin = { top: 30, right: 30, bottom: 60, left: 140 };
            const width = 600 - margin.left - margin.right;
            const height = 500 - margin.top - margin.bottom;

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const totalGreen = d3.sum(metrics, d => d.green_area_km2 * 1e6);
            const totalPop = d3.sum(metrics, d => d.population);
            const mean = totalGreen / totalPop;

            const data = metrics
                .filter(d => d.population > 0 && d.green_per_capita_m2 >= 0)
                .map(d => ({
                    pa: d.pa,
                    diff: d.green_per_capita_m2 - mean,
                    green_per_capita_m2: d.green_per_capita_m2
                }))
                .sort((a, b) => d3.ascending(a.diff, b.diff));

            const x = d3.scaleLinear()
                .domain(d3.extent(data, d => d.diff))
                .nice()
                .range([0, width]);

            const y = d3.scaleBand()
                .domain(data.map(d => d.pa))
                .range([height, 0])
                .padding(0.2);

            // Zero line
            g.append('line')
                .attr('x1', x(0))
                .attr('x2', x(0))
                .attr('y1', 0)
                .attr('y2', height)
                .attr('stroke', '#6b7280')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickFormat(d => d3.format('+.1f')(d)))
                .selectAll('text')
                .attr('fill', '#d1d5db')
                .attr('font-size', '10px');

            g.append('g')
                .call(d3.axisLeft(y))
                .selectAll('text')
                .attr('fill', '#d1d5db')
                .attr('font-size', '10px');

            g.append('text')
                .attr('x', width / 2)
                .attr('y', height + 40)
                .attr('text-anchor', 'middle')
                .attr('fill', '#e7e9ee')
                .attr('font-size', '12px')
                .text('Difference (m²/person)');

            // Bars
            g.selectAll('rect')
                .data(data)
                .join('rect')
                .attr('x', d => Math.min(x(d.diff), x(0)))
                .attr('y', d => y(d.pa))
                .attr('width', d => Math.abs(x(d.diff) - x(0)))
                .attr('height', y.bandwidth())
                .attr('fill', d => d.diff >= 0 ? '#2ca02c' : '#d62728')
                .attr('opacity', d => d.diff >= 0 ? 0.9 : 0.95)
                .attr('stroke', d => d.diff >= 0 ? 'none' : '#fff')
                .attr('stroke-width', d => d.diff >= 0 ? 0 : 0.5)
                .on('mousemove', (ev, d) => {
                    showTip(`<strong>${d.pa}</strong><br/>Difference: ${d3.format('+.2f')(d.diff)} m²<br/>Per Capita: ${d3.format('.2f')(d.green_per_capita_m2)} m²`, ev.clientX, ev.clientY);
                })
                .on('mouseleave', hideTip);

            // Title
            g.append('text')
                .attr('x', width / 2)
                .attr('y', -10)
                .attr('text-anchor', 'middle')
                .attr('fill', '#e7e9ee')
                .attr('font-size', '13px')
                .text(`National Average: ${d3.format('.2f')(mean)} m²/person`);

            // Legend
            const legend = g.append('g')
                .attr('transform', `translate(${width - 130}, 20)`);

            legend.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', 20)
                .attr('height', 15)
                .attr('fill', '#2ca02c')
                .attr('opacity', 0.9);

            legend.append('text')
                .attr('x', 25)
                .attr('y', 12)
                .attr('fill', '#d1d5db')
                .attr('font-size', '12px')
                .text('Above Average');

            legend.append('rect')
                .attr('x', 0)
                .attr('y', 25)
                .attr('width', 20)
                .attr('height', 15)
                .attr('fill', '#d62728')
                .attr('opacity', 0.95)
                .attr('stroke', '#fff')
                .attr('stroke-width', 0.5);

            legend.append('text')
                .attr('x', 25)
                .attr('y', 37)
                .attr('fill', '#d1d5db')
                .attr('font-size', '12px')
                .text('Below Average');
        }

        function renderChoropleth(metrics, geo) {
            const svg = d3.select('#map')
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('viewBox', '0 0 1200 600');

            const margin = { top: 30, right: 20, bottom: 30, left: 20 };
            const width = 1200 - margin.left - margin.right;
            const height = 600 - margin.top - margin.bottom;

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const paByName = new Map(metrics.map(d => [d.pa.toUpperCase(), d]));
            const features = geo.features;

            let matchedCount = 0;
            const values = features.map(f => {
                const name = selectPAName(f.properties);
                const m = findMatchingData(name, paByName);
                if (m) matchedCount++;
                return m ? +m.green_per_capita_m2 : NaN;
            }).filter(v => !Number.isNaN(v) && v > 0);

            console.log(`Choropleth: matched ${matchedCount} out of ${features.length} features`);
            console.log(`Choropleth: valid values: ${values.length}`);

            if (values.length === 0) {
                svg.append('text')
                    .attr('x', '50%')
                    .attr('y', '50%')
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#e7e9ee')
                    .text(`无法加载数据。匹配: ${matchedCount}/${features.length}`);
                return;
            }

            const color = d3.scaleQuantile()
                .domain(values)
                .range(d3.schemeGreens[7]);

            const proj = d3.geoMercator().fitSize([width, height], geo);
            const path = d3.geoPath(proj);

            // Map regions
            g.selectAll('path.region').data(features).join('path')
                .attr('class', 'region')
                .attr('d', path)
                .attr('fill', f => {
                    const name = selectPAName(f.properties);
                    const m = findMatchingData(name, paByName);
                    return m && m.green_per_capita_m2 > 0.01 ? color(m.green_per_capita_m2) : '#ffffff';
                })
                .attr('stroke', '#1a1d24')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.9)
                .on('mouseenter', function () {
                    d3.select(this).attr('stroke', '#5dc16b').attr('stroke-width', 2).attr('opacity', 1);
                })
                .on('mouseleave', function () {
                    d3.select(this).attr('stroke', '#1a1d24').attr('stroke-width', 0.5).attr('opacity', 0.9);
                })
                .on('mousemove', (ev, f) => {
                    const name = selectPAName(f.properties);
                    const m = findMatchingData(name, paByName);
                    if (m) {
                        showTip(`<strong>${name}</strong><br/>Per Capita Green: ${d3.format('.2f')(m.green_per_capita_m2)} m²<br/>Population: ${d3.format(',.0f')(m.population)}<br/>Green Area: ${d3.format('.2f')(m.green_area_km2)} km²`, ev.clientX, ev.clientY);
                    }
                })
                .on('mouseleave', hideTip);

            // Add legend
            const legendW = 300, legendH = 15;
            const legendX = width - legendW - 20;
            const legendY = height - 40;
            const legend = g.append('g').attr('transform', `translate(${legendX},${legendY})`);
            
            const steps = color.quantiles();
            const stops = [d3.min(values), ...steps, d3.max(values)];
            const legendStep = legendW / (stops.length - 1);
            
            legend.selectAll('rect')
                .data(d3.pairs(stops))
                .join('rect')
                .attr('x', (d, i) => i * legendStep)
                .attr('y', 0)
                .attr('width', legendStep)
                .attr('height', legendH)
                .attr('fill', d => color((d[0] + d[1]) / 2))
                .attr('stroke', '#666')
                .attr('stroke-width', 0.5);
            
            legend.append('text')
                .attr('x', 0)
                .attr('y', legendH + 16)
                .attr('fill', '#d1d5db')
                .attr('font-size', '11px')
                .text(d3.format('.1f')(d3.min(values)));
            
            legend.append('text')
                .attr('x', legendW)
                .attr('y', legendH + 16)
                .attr('text-anchor', 'end')
                .attr('fill', '#d1d5db')
                .attr('font-size', '11px')
                .text(d3.format('.1f')(d3.max(values)) + ' m²/person');
            
            legend.append('text')
                .attr('x', legendW / 2)
                .attr('y', -8)
                .attr('text-anchor', 'middle')
                .attr('fill', '#e7e9ee')
                .attr('font-size', '13px')
                .attr('font-weight', 'bold')
                .text('Per Capita Green Space (darker = more)');

            // Responsive
            new ResizeObserver(entries => {
                for (let entry of entries) {
                    const { width: w, height: h } = entry.contentRect;
                    svg.attr('viewBox', `0 0 ${Math.max(w, 1200)} ${Math.max(h, 600)}`);
                    if (w > 0 && h > 0) {
                        const newW = w - margin.left - margin.right;
                        const newH = h - margin.top - margin.bottom;
                        if (newW > 0 && newH > 0) {
                            proj.fitSize([newW, newH], geo);
                            g.selectAll('path.region').attr('d', path);
                        }
                    }
                }
            }).observe(svg.node());
        }

        // Initialize
        (async function () {
            try {
                console.log('Loading data...');
                const { metrics, geo } = await loadData();
                console.log('Data loaded successfully');
                console.log('Metrics:', metrics.length);
                console.log('Geo features:', geo.features.length);
                
                // Debug: check name matching
                const sampleMetrics = metrics.slice(0, 5).map(m => m.pa);
                const sampleGeo = geo.features.slice(0, 5).map(f => selectPAName(f.properties));
                console.log('Sample metrics names:', sampleMetrics);
                console.log('Sample geo names:', sampleGeo);
                
                renderScatter(metrics);
                renderDivergingBars(metrics);
                renderChoropleth(metrics, geo);
                
                console.log('All visualizations rendered!');
            } catch (err) {
                console.error('Error:', err);
                document.querySelector('.container').innerHTML = 
                    '<p style="color: #e7e9ee; text-align: center;">无法加载数据。请检查网络连接和文件路径。</p>';
            }
        })();
    </script>
</body>

</html>
